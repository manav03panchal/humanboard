<!-- Source: https://deepwiki.com/zed-industries/zed/2.3-window-and-platform-abstraction -->

# 2.3 Window And Platform Abstraction

Loading...

Index your code with Devin

[DeepWiki](</>)

[DeepWiki](</>)

[zed-industries/zed ](<https://github.com/zed-industries/zed> "Open repository")

Index your code with

Devin

Edit WikiShare

Loading...

Last indexed: 16 December 2025 ([4109c9](<https://github.com/zed-industries/zed/commits/4109c9dd>))

  * [Overview](</zed-industries/zed/1-overview>)
  * [Core Architecture](</zed-industries/zed/2-core-architecture>)
  * [Application Initialization and Lifecycle](</zed-industries/zed/2.1-application-initialization-and-lifecycle>)
  * [GPUI Framework](</zed-industries/zed/2.2-gpui-framework>)
  * [Window and Platform Abstraction](</zed-industries/zed/2.3-window-and-platform-abstraction>)
  * [Event Flow and Input Handling](</zed-industries/zed/2.4-event-flow-and-input-handling>)
  * [Keybinding and Action System](</zed-industries/zed/2.5-keybinding-and-action-system>)
  * [Focus Management and Hit Testing](</zed-industries/zed/2.6-focus-management-and-hit-testing>)
  * [Editor Architecture](</zed-industries/zed/3-editor-architecture>)
  * [Editor Component and UI](</zed-industries/zed/3.1-editor-component-and-ui>)
  * [Buffer System and Text Storage](</zed-industries/zed/3.2-buffer-system-and-text-storage>)
  * [Display Pipeline and Rendering](</zed-industries/zed/3.3-display-pipeline-and-rendering>)
  * [Selections and Editing Operations](</zed-industries/zed/3.4-selections-and-editing-operations>)
  * [Code Intelligence Integration](</zed-industries/zed/3.5-code-intelligence-integration>)
  * [Diff Integration](</zed-industries/zed/3.6-diff-integration>)
  * [Workspace and Panel System](</zed-industries/zed/4-workspace-and-panel-system>)
  * [Workspace Organization](</zed-industries/zed/4.1-workspace-organization>)
  * [Item System and Lifecycle](</zed-industries/zed/4.2-item-system-and-lifecycle>)
  * [Pane Management](</zed-industries/zed/4.3-pane-management>)
  * [Search System](</zed-industries/zed/4.4-search-system>)
  * [Project Management](</zed-industries/zed/5-project-management>)
  * [Project Orchestration](</zed-industries/zed/5.1-project-orchestration>)
  * [Worktree and File System](</zed-industries/zed/5.2-worktree-and-file-system>)
  * [Buffer Store](</zed-industries/zed/5.3-buffer-store>)
  * [Language Intelligence](</zed-industries/zed/6-language-intelligence>)
  * [LSP Store Architecture](</zed-industries/zed/6.1-lsp-store-architecture>)
  * [Language Server Lifecycle](</zed-industries/zed/6.2-language-server-lifecycle>)
  * [Completions and Diagnostics](</zed-industries/zed/6.3-completions-and-diagnostics>)
  * [Multi-Language Server Coordination](</zed-industries/zed/6.4-multi-language-server-coordination>)
  * [Settings and Configuration](</zed-industries/zed/7-settings-and-configuration>)
  * [Settings Store and Layering](</zed-industries/zed/7.1-settings-store-and-layering>)
  * [Settings UI](</zed-industries/zed/7.2-settings-ui>)
  * [Settings Migration](</zed-industries/zed/7.3-settings-migration>)
  * [Keymap System](</zed-industries/zed/7.4-keymap-system>)
  * [Git Integration](</zed-industries/zed/8-git-integration>)
  * [Git Panel and UI](</zed-industries/zed/8.1-git-panel-and-ui>)
  * [Git Store and State Management](</zed-industries/zed/8.2-git-store-and-state-management>)
  * [Repository Operations](</zed-industries/zed/8.3-repository-operations>)
  * [Diff System](</zed-industries/zed/8.4-diff-system>)
  * [Terminal and Task Execution](</zed-industries/zed/9-terminal-and-task-execution>)
  * [Terminal Core](</zed-industries/zed/9.1-terminal-core>)
  * [Terminal View and Rendering](</zed-industries/zed/9.2-terminal-view-and-rendering>)
  * [Task System](</zed-industries/zed/9.3-task-system>)
  * [Vim Mode](</zed-industries/zed/10-vim-mode>)
  * [Mode State Machine](</zed-industries/zed/10.1-mode-state-machine>)
  * [Operators, Motions, and Objects](</zed-industries/zed/10.2-operators-motions-and-objects>)
  * [Visual Mode](</zed-industries/zed/10.3-visual-mode>)
  * [Helix Mode Integration](</zed-industries/zed/10.4-helix-mode-integration>)
  * [AI Agent System](</zed-industries/zed/11-ai-agent-system>)
  * [Agent Communication Protocol (ACP)](</zed-industries/zed/11.1-agent-communication-protocol-\(acp\)>)
  * [Agent UI and Thread Management](</zed-industries/zed/11.2-agent-ui-and-thread-management>)
  * [Agent Connection and Implementations](</zed-industries/zed/11.3-agent-connection-and-implementations>)
  * [Tool System](</zed-industries/zed/11.4-tool-system>)
  * [Mention System and Context](</zed-industries/zed/11.5-mention-system-and-context>)
  * [Legacy Agent Thread System](</zed-industries/zed/11.6-legacy-agent-thread-system>)
  * [Remote Development and Collaboration](</zed-industries/zed/12-remote-development-and-collaboration>)
  * [Local vs Remote Architecture](</zed-industries/zed/12.1-local-vs-remote-architecture>)
  * [Remote Project Architecture](</zed-industries/zed/12.2-remote-project-architecture>)
  * [Collaboration Features](</zed-industries/zed/12.3-collaboration-features>)
  * [CRDT and Synchronization](</zed-industries/zed/12.4-crdt-and-synchronization>)


Menu

# Window and Event System

Relevant source files

  * [crates/gpui/examples/mouse_pressure.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/examples/mouse_pressure.rs>)
  * [crates/gpui/src/app.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/app.rs>)
  * [crates/gpui/src/interactive.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/interactive.rs>)
  * [crates/gpui/src/key_dispatch.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/key_dispatch.rs>)
  * [crates/gpui/src/keymap.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/keymap.rs>)
  * [crates/gpui/src/platform.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform.rs>)
  * [crates/gpui/src/platform/linux/headless/client.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/headless/client.rs>)
  * [crates/gpui/src/platform/linux/platform.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/platform.rs>)
  * [crates/gpui/src/platform/linux/wayland/client.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/wayland/client.rs>)
  * [crates/gpui/src/platform/linux/wayland/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/wayland/window.rs>)
  * [crates/gpui/src/platform/linux/x11/client.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/x11/client.rs>)
  * [crates/gpui/src/platform/linux/x11/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/x11/window.rs>)
  * [crates/gpui/src/platform/mac/events.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/events.rs>)
  * [crates/gpui/src/platform/mac/platform.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/platform.rs>)
  * [crates/gpui/src/platform/mac/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/window.rs>)
  * [crates/gpui/src/platform/test/platform.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/test/platform.rs>)
  * [crates/gpui/src/platform/test/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/test/window.rs>)
  * [crates/gpui/src/platform/windows/events.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/events.rs>)
  * [crates/gpui/src/platform/windows/platform.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/platform.rs>)
  * [crates/gpui/src/platform/windows/util.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/util.rs>)
  * [crates/gpui/src/platform/windows/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/window.rs>)
  * [crates/gpui/src/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs>)
  * [crates/ui/src/components/keybinding.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/ui/src/components/keybinding.rs>)


This document describes GPUI's window management, platform input abstraction, event dispatch system, hit testing mechanism, focus management, and the multi-phase rendering pipeline. Together, these components handle all interactions between the user, the operating system, and the application's UI elements.

For information about how keystroke events are matched to actions and dispatched to handlers, see [Keybinding and Action Dispatch](</zed-industries/zed/2.4-event-flow-and-input-handling>). For details on how the GPUI framework initializes and manages the application lifecycle, see [Application Initialization and Lifecycle](</zed-industries/zed/2.1-application-initialization-and-lifecycle>).

## Window Lifecycle and Platform Abstraction

GPUI abstracts platform-specific window behavior behind the `PlatformWindow` trait, with concrete implementations for each supported platform.


**Platform Window Creation Flow**

Sources: [crates/gpui/src/window.rs1003-1096](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1003-L1096>) [crates/gpui/src/platform.rs165-278](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform.rs#L165-L278>)

A `Window` is created through the `Platform::open_window` method, which:

  1. Accepts a `WindowParams` struct with bounds, decorations, kind (normal/popup), and display settings
  2. Creates a platform-specific window via `PlatformWindow` implementor
  3. Initializes the `Window` state with rendering context, focus system, and event handlers
  4. Returns an `AnyWindowHandle` for referencing the window


The `Window` struct [crates/gpui/src/window.rs832-891](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L832-L891>) contains:

  * `platform_window`: Box \- platform-specific window implementation
  * `root`: Option \- the root view being rendered
  * `rendered_frame` and `next_frame`: Frame structs for double-buffered rendering
  * `focus`: Option \- currently focused element
  * `mouse_position` and `mouse_hit_test`: mouse state and hit testing results
  * `invalidator`: WindowInvalidator - tracks when window needs redraw


Sources: [crates/gpui/src/window.rs832-891](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L832-L891>) [crates/gpui/src/platform.rs207-211](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform.rs#L207-L211>)

## Platform Input Abstraction

All user input from the operating system is normalized into the `PlatformInput` enum before being processed by GPUI.


**Input Event Structure**

The `PlatformInput` enum [crates/gpui/src/platform.rs38-45](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform.rs#L38-L45>) defines all possible input events:

Event Type| Key Fields| Description  
---|---|---  
`MouseDown`| button, position, modifiers, click_count| Button press with multi-click detection  
`MouseUp`| button, position, modifiers, click_count| Button release  
`MouseMove`| position, pressed_button, modifiers| Cursor movement, optionally during drag  
`MouseExit`| position| Cursor left window bounds  
`ScrollWheel`| position, delta, modifiers, touch_phase| Scroll events with pixel or line deltas  
`KeyDown`| keystroke, is_held, prefer_character_input| Key press with repeat detection  
`KeyUp`| keystroke| Key release  
`ModifiersChanged`| modifiers| Modifier key state change  
`FileDropEvent`| position, paths| File drag-and-drop  
  
Sources: [crates/gpui/src/platform.rs38-67](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform.rs#L38-L67>) [crates/gpui/src/platform/mac/events.rs1-317](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/events.rs#L1-L317>) [crates/gpui/src/platform/windows/events.rs1-810](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/events.rs#L1-L810>)

**Keystroke Normalization**

Platform-specific key codes are converted to `Keystroke` objects [crates/gpui/src/platform/keystroke.rs17-33](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/keystroke.rs#L17-L33>) containing:

  * `modifiers`: Modifiers struct (control, alt, shift, platform, function)
  * `key`: The physical key label (e.g., "s", "enter", "escape")
  * `key_char`: Optional character that would be typed (handles IME and alternate layouts)


Sources: [crates/gpui/src/platform/keystroke.rs17-33](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/keystroke.rs#L17-L33>) [crates/gpui/src/platform/mac/events.rs20-317](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/events.rs#L20-L317>) [crates/gpui/src/platform/windows/events.rs344-369](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/events.rs#L344-L369>)

## Event Dispatch System

Event dispatch in GPUI follows a two-phase model: **capture phase** (root to target) and **bubble phase** (target to root).


**Dispatch Phases**

The `DispatchPhase` enum [crates/gpui/src/window.rs70-99](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L70-L99>) defines two phases:

  1. **Capture Phase** (`DispatchPhase::Capture`):

     * Mouse events: back to front (farthest to nearest)
     * Keyboard events: root to focused element
     * Used for clearing state, preventing default behavior
     * Example: Clearing button "pressed" state when click moves outside button bounds
  2. **Bubble Phase** (`DispatchPhase::Bubble`):

     * Mouse events: front to back (nearest to farthest)
     * Keyboard events: focused element to root
     * Standard event handling phase where most handlers execute
     * Example: Button click handlers, text input


Sources: [crates/gpui/src/window.rs70-99](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L70-L99>)

**Event Propagation Control**

Event handlers return `DispatchEventResult` [crates/gpui/src/window.rs3195-3199](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L3195-L3199>) with:

  * `propagate`: bool - if false, stops further propagation
  * `default_prevented`: bool - if true, prevents default browser-like behavior


Calling `cx.stop_propagation()` in a handler sets `propagate = false`, preventing the event from reaching subsequent handlers.

Sources: [crates/gpui/src/window.rs3195-3212](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L3195-L3212>)

**Mouse Event Dispatch**

Mouse event dispatch [crates/gpui/src/window.rs3213-3345](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L3213-L3345>) follows this flow:

  1. Update `mouse_position` from event
  2. Perform hit test to get affected hitboxes (for mouse events)
  3. Dispatch CAPTURE phase listeners
  4. If event not stopped, dispatch BUBBLE phase listeners
  5. Update cursor style based on hovered hitboxes


Keyboard events [crates/gpui/src/window.rs3346-3476](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L3346-L3476>) follow the dispatch tree from focused element to root rather than using hit testing.

Sources: [crates/gpui/src/window.rs3213-3476](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L3213-L3476>)

## Hit Testing and Mouse Events

Hit testing determines which UI elements are under the mouse cursor and should receive mouse events.


**Hitbox System**

A `Hitbox` [crates/gpui/src/window.rs532-543](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L532-L543>) represents a rectangular region that can receive mouse events:

  * `id`: HitboxId - unique identifier for checking hover state
  * `bounds`: Bounds \- rectangular area
  * `content_mask`: ContentMask \- clipping region
  * `behavior`: HitboxBehavior - how it affects other hitboxes


**Hit Testing Algorithm**

The `Frame::hit_test` method [crates/gpui/src/window.rs782-804](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L782-L804>) processes hitboxes in reverse order (front to back):

  1. Iterate through `Frame.hitboxes` in reverse
  2. For each hitbox, check if mouse position is within bounds âˆ© content_mask
  3. Add hitbox ID to result
  4. If hitbox has `BlockMouseExceptScroll`, mark the split point for `hover_hitbox_count`
  5. If hitbox has `BlockMouse`, stop iteration
  6. Return `HitTest` with IDs and hover count


The distinction between `is_hovered()` and `should_handle_scroll()` allows for overlays that block mouse interaction but still allow scrolling through them.

Sources: [crates/gpui/src/window.rs498-573](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L498-L573>) [crates/gpui/src/window.rs782-804](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L782-L804>)

**HitboxBehavior Semantics**

Behavior| is_hovered()| should_handle_scroll()| Use Case  
---|---|---|---  
`Normal`| true if under cursor| true if under cursor| Standard interactive elements  
`BlockMouse`| false for elements behind| false for elements behind| Modal overlays, context menus  
`BlockMouseExceptScroll`| false for elements behind| true for elements behind| Semi-transparent overlays  
  
The `BlockMouseExceptScroll` variant is set via `InteractiveElement::block_mouse_except_scroll()` and is used for scenarios where you want an overlay that prevents clicks but allows scrolling the content underneath.

Sources: [crates/gpui/src/window.rs575-632](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L575-L632>)

## Focus System

The focus system tracks which element has keyboard focus and manages focus changes, tab navigation, and focus-relative event dispatch.


**FocusHandle Lifecycle**

`FocusHandle` [crates/gpui/src/window.rs272-383](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L272-L383>) is a reference-counted handle to a focusable element:

  1. Created via `FocusHandle::new(handles: &Arc<FocusMap>)` [crates/gpui/src/window.rs289-302](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L289-L302>)
  2. Inserted into global `FocusMap` slotmap with `ref_count = 1`
  3. Clone increments ref count [crates/gpui/src/window.rs385-389](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L385-L389>)
  4. Drop decrements ref count [crates/gpui/src/window.rs399-408](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L399-L408>)
  5. When ref_count reaches 0, entry becomes available for reuse


Each `FocusHandle` has:

  * `id`: FocusId - unique identifier in slotmap
  * `tab_index`: isize - position in tab order (default 0)
  * `tab_stop`: bool - whether included in tab navigation (default false)


Sources: [crates/gpui/src/window.rs272-408](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L272-L408>)

**Focus Path and Containment**

The focus path is a chain from the focused element to the root of the element tree, computed via `Frame::focus_path()` [crates/gpui/src/window.rs806-811](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L806-L811>) This enables:

  * `FocusId::contains(other, window)`: Check if this focus ID is an ancestor of another [crates/gpui/src/window.rs264-269](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L264-L269>)
  * `FocusHandle::contains_focused()`: Check if focused element is a descendant [crates/gpui/src/window.rs357-360](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L357-L360>)


These are used to determine if keyboard events should be delivered to an element when not directly focused.

Sources: [crates/gpui/src/window.rs806-811](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L806-L811>) [crates/gpui/src/window.rs264-269](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L264-L269>)

**Tab Navigation**

Tab stops are maintained in a `TabStopMap` which stores focusable elements sorted by `(tab_index, insertion_order)`. Tab navigation [crates/gpui/src/window.rs2671-2715](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L2671-L2715>):

  1. Collect all `FocusHandle`s with `tab_stop = true` from the rendered frame
  2. Sort by tab_index, then by insertion order
  3. For forward: find next handle after current focus (wrapping to start)
  4. For backward: find previous handle (wrapping to end)
  5. Call `focus_handle.focus(window)` to move focus


The `Focusable` trait [crates/gpui/src/window.rs447-456](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L447-L456>) allows views to expose their focus handle for external focus management.

Sources: [crates/gpui/src/window.rs2671-2715](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L2671-L2715>) [crates/gpui/src/window.rs447-456](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L447-L456>)

## Rendering Pipeline Phases

GPUI uses a three-phase rendering pipeline: **prepaint** (layout), **paint** (scene construction), and **present** (display).


**Phase Tracking**

The `WindowInvalidator` [crates/gpui/src/window.rs101-185](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L101-L185>) tracks the current draw phase:


Certain operations are only valid during specific phases, checked with `debug_assert_prepaint()` and `debug_assert_paint()`.

Sources: [crates/gpui/src/window.rs101-185](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L101-L185>) [crates/gpui/src/window.rs900-906](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L900-L906>)

**Prepaint Phase: Layout Calculation**

The prepaint phase [crates/gpui/src/window.rs1699-1928](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1699-L1928>) computes layout and builds the dispatch tree:

  1. **Clear previous frame state** : Reset hitboxes, mouse listeners, scene, dispatch tree
  2. **Layout computation** : 
     * Call `element.prepaint()` on root view
     * Elements request Taffy layouts via `cx.request_layout()`
     * Taffy computes flex/grid/absolute positioning
     * Returns `LayoutId` for each element
  3. **Build DispatchTree** : Construct tree of dispatch nodes for event routing
  4. **Record hitboxes** : Elements insert hitboxes via `cx.insert_hitbox()`
  5. **Queue deferred draws** : Elements with `z_index` or `absolute` positioning queue deferred renders
  6. **Compute focus path** : Build chain from focused element to root


The prepaint phase does NOT modify the `Scene` \- it only computes positions and sizes.

Sources: [crates/gpui/src/window.rs1699-1928](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1699-L1928>)

**Paint Phase: Scene Construction**

The paint phase [crates/gpui/src/window.rs1930-2053](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1930-L2053>) constructs the visual scene:

  1. **Execute deferred draws** : Process elements queued during prepaint, sorted by priority
  2. **Paint elements** : Call `element.paint()` on all elements
  3. **Add primitives to Scene** : 
     * Quads (colored rectangles with borders, shadows, corners)
     * Paths (vector graphics)
     * Glyphs (text)
     * Images (raster graphics)
     * SVGs
  4. **Record mouse listeners** : Store callbacks for mouse events on hitboxes
  5. **Record input handlers** : Store IME input handlers for text input
  6. **Record tooltip requests** : Elements can request tooltips to be shown


The `Scene` [crates/gpui/src/scene.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/scene.rs>) is a retained structure containing all draw commands, which is then passed to the platform-specific renderer.

Sources: [crates/gpui/src/window.rs1930-2053](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1930-L2053>)

**Present Phase: Display Update**

After painting, `Window::present()` [crates/gpui/src/window.rs2055-2072](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L2055-L2072>) finalizes the frame:

  1. Call `Frame::finish(&mut prev_frame)` to merge element states
  2. Extract cursor style from hovered hitboxes
  3. Call `platform_window.present_scene(scene)`
  4. Platform renderer (BladeRenderer for most platforms) uploads to GPU
  5. GPU composites and displays the frame


The platform window may use vsync or adaptive sync to control frame presentation timing.

Sources: [crates/gpui/src/window.rs2055-2072](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L2055-L2072>)

**Double-Buffered Frame State**

The `Window` maintains two `Frame` structs [crates/gpui/src/window.rs857-858](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L857-L858>):

  * `rendered_frame`: Last successfully rendered frame (for hit testing, focus queries)
  * `next_frame`: Frame being constructed in current draw


This double buffering allows the system to query the previous frame's state while building the next one, essential for hit testing and event dispatch which reference the last rendered positions.

Sources: [crates/gpui/src/window.rs857-858](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L857-L858>) [crates/gpui/src/window.rs718-745](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L718-L745>)

## Window Invalidation and Refresh

Windows are invalidated when their content changes, triggering a redraw in the next frame.


**View Invalidation**

When a view's state changes, it calls `cx.notify()` [crates/gpui/src/app/context.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/app/context.rs>) which:

  1. Pushes `Effect::Notify { emitter: EntityId }` to the app's effect queue
  2. During `App::flush_effects()`, the effect is processed
  3. For each window containing the view, `WindowInvalidator::invalidate_view()` is called [crates/gpui/src/window.rs123-133](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L123-L133>)
  4. If not currently drawing, sets `dirty = true` and pushes another notify effect


This lazy invalidation approach coalesces multiple changes into a single redraw.

Sources: [crates/gpui/src/window.rs101-185](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L101-L185>) [crates/gpui/src/window.rs123-133](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L123-L133>)

**Request Frame Callback**

Each window has a `request_frame` callback [crates/gpui/src/window.rs1505-1519](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1505-L1519>) registered with the platform window. When the window needs a redraw:

  1. `WindowInvalidator::invalidate_view()` calls the platform callback
  2. Platform schedules a frame (typically at vsync)
  3. On next frame opportunity, platform invokes the callback with `RequestFrameOptions`
  4. The callback calls `Window::draw()` if the window is still dirty


The `RequestFrameOptions` struct contains:

  * `refresh_rate`: Optional \- display refresh rate
  * `vsync`: bool - whether vsync is enabled


Sources: [crates/gpui/src/window.rs1505-1519](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1505-L1519>)

**Platform-Specific Refresh Mechanisms**

Platform| Mechanism| Location  
---|---|---  
macOS| CVDisplayLink callback tied to display refresh| [crates/gpui/src/platform/mac/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/window.rs>)  
Windows| Vsync provider thread + RedrawWindow messages| [crates/gpui/src/platform/windows/platform.rs249-287](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/platform.rs#L249-L287>)  
Linux X11| Calloop event loop with frame callback timers| [crates/gpui/src/platform/linux/x11/client.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/x11/client.rs>)  
Linux Wayland| wl_surface frame callbacks| [crates/gpui/src/platform/linux/wayland/client.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/linux/wayland/client.rs>)  
  
On macOS, a `DisplayLink` [crates/gpui/src/platform/mac/window.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/window.rs>) is created per window, firing at the display's refresh rate. On Windows, a separate vsync thread uses `DwmFlush()` to sync with DWM composition. On Linux, platform-specific frame callback mechanisms trigger redraws.

Sources: [crates/gpui/src/platform/mac/window.rs388-422](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/mac/window.rs#L388-L422>) [crates/gpui/src/platform/windows/platform.rs249-287](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/platform/windows/platform.rs#L249-L287>)

**Partial Invalidation**

The `WindowInvalidator` tracks which views are dirty in `dirty_views: FxHashSet<EntityId>` [crates/gpui/src/window.rs104](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L104-L104>) allowing for future optimization of partial redraws (though currently the entire window is repainted each frame).

During the draw phase, `invalidator.set_phase(DrawPhase::Prepaint)` is set to prevent invalidation during rendering, avoiding infinite loops.

Sources: [crates/gpui/src/window.rs101-185](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L101-L185>) [crates/gpui/src/window.rs1699-1702](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/gpui/src/window.rs#L1699-L1702>)

## Summary

The Window and Event System in GPUI provides:

  1. **Platform Abstraction** : Uniform `PlatformWindow` and `PlatformInput` interfaces across macOS, Windows, and Linux (X11/Wayland)

  2. **Two-Phase Event Dispatch** : Capture and bubble phases enable both global event interception and local event handling with propagation control

  3. **Hit Testing** : Efficient determination of which UI elements are under the mouse, with behavior flags for controlling interaction blocking

  4. **Focus Management** : Reference-counted focus handles with tab navigation, focus paths, and containment queries

  5. **Three-Phase Rendering** : Prepaint for layout, paint for scene construction, present for display, with strict phase enforcement

  6. **Smart Invalidation** : Lazy invalidation with view-level tracking and platform-specific refresh scheduling tied to display vsync


This architecture allows GPUI to provide a consistent, high-performance UI framework across different operating systems while maintaining precise control over event handling and rendering.

Dismiss

Refresh this wiki

This wiki was recently refreshed. Please wait 7 days to refresh again.

### On this page

  * [Window and Event System](<#window-and-event-system>)
  * [Window Lifecycle and Platform Abstraction](<#window-lifecycle-and-platform-abstraction>)
  * [Platform Input Abstraction](<#platform-input-abstraction>)
  * [Event Dispatch System](<#event-dispatch-system>)
  * [Hit Testing and Mouse Events](<#hit-testing-and-mouse-events>)
  * [Focus System](<#focus-system>)
  * [Rendering Pipeline Phases](<#rendering-pipeline-phases>)
  * [Window Invalidation and Refresh](<#window-invalidation-and-refresh>)
  * [Summary](<#summary>)
