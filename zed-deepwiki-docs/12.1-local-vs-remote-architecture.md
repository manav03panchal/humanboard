<!-- Source: https://deepwiki.com/zed-industries/zed/12.1-local-vs-remote-architecture -->

# 12.1 Local Vs Remote Architecture

Loading...

Index your code with Devin

[DeepWiki](</>)

[DeepWiki](</>)

[zed-industries/zed ](<https://github.com/zed-industries/zed> "Open repository")

Index your code with

Devin

Edit WikiShare

Loading...

Last indexed: 16 December 2025 ([4109c9](<https://github.com/zed-industries/zed/commits/4109c9dd>))

  * [Overview](</zed-industries/zed/1-overview>)
  * [Core Architecture](</zed-industries/zed/2-core-architecture>)
  * [Application Initialization and Lifecycle](</zed-industries/zed/2.1-application-initialization-and-lifecycle>)
  * [GPUI Framework](</zed-industries/zed/2.2-gpui-framework>)
  * [Window and Platform Abstraction](</zed-industries/zed/2.3-window-and-platform-abstraction>)
  * [Event Flow and Input Handling](</zed-industries/zed/2.4-event-flow-and-input-handling>)
  * [Keybinding and Action System](</zed-industries/zed/2.5-keybinding-and-action-system>)
  * [Focus Management and Hit Testing](</zed-industries/zed/2.6-focus-management-and-hit-testing>)
  * [Editor Architecture](</zed-industries/zed/3-editor-architecture>)
  * [Editor Component and UI](</zed-industries/zed/3.1-editor-component-and-ui>)
  * [Buffer System and Text Storage](</zed-industries/zed/3.2-buffer-system-and-text-storage>)
  * [Display Pipeline and Rendering](</zed-industries/zed/3.3-display-pipeline-and-rendering>)
  * [Selections and Editing Operations](</zed-industries/zed/3.4-selections-and-editing-operations>)
  * [Code Intelligence Integration](</zed-industries/zed/3.5-code-intelligence-integration>)
  * [Diff Integration](</zed-industries/zed/3.6-diff-integration>)
  * [Workspace and Panel System](</zed-industries/zed/4-workspace-and-panel-system>)
  * [Workspace Organization](</zed-industries/zed/4.1-workspace-organization>)
  * [Item System and Lifecycle](</zed-industries/zed/4.2-item-system-and-lifecycle>)
  * [Pane Management](</zed-industries/zed/4.3-pane-management>)
  * [Search System](</zed-industries/zed/4.4-search-system>)
  * [Project Management](</zed-industries/zed/5-project-management>)
  * [Project Orchestration](</zed-industries/zed/5.1-project-orchestration>)
  * [Worktree and File System](</zed-industries/zed/5.2-worktree-and-file-system>)
  * [Buffer Store](</zed-industries/zed/5.3-buffer-store>)
  * [Language Intelligence](</zed-industries/zed/6-language-intelligence>)
  * [LSP Store Architecture](</zed-industries/zed/6.1-lsp-store-architecture>)
  * [Language Server Lifecycle](</zed-industries/zed/6.2-language-server-lifecycle>)
  * [Completions and Diagnostics](</zed-industries/zed/6.3-completions-and-diagnostics>)
  * [Multi-Language Server Coordination](</zed-industries/zed/6.4-multi-language-server-coordination>)
  * [Settings and Configuration](</zed-industries/zed/7-settings-and-configuration>)
  * [Settings Store and Layering](</zed-industries/zed/7.1-settings-store-and-layering>)
  * [Settings UI](</zed-industries/zed/7.2-settings-ui>)
  * [Settings Migration](</zed-industries/zed/7.3-settings-migration>)
  * [Keymap System](</zed-industries/zed/7.4-keymap-system>)
  * [Git Integration](</zed-industries/zed/8-git-integration>)
  * [Git Panel and UI](</zed-industries/zed/8.1-git-panel-and-ui>)
  * [Git Store and State Management](</zed-industries/zed/8.2-git-store-and-state-management>)
  * [Repository Operations](</zed-industries/zed/8.3-repository-operations>)
  * [Diff System](</zed-industries/zed/8.4-diff-system>)
  * [Terminal and Task Execution](</zed-industries/zed/9-terminal-and-task-execution>)
  * [Terminal Core](</zed-industries/zed/9.1-terminal-core>)
  * [Terminal View and Rendering](</zed-industries/zed/9.2-terminal-view-and-rendering>)
  * [Task System](</zed-industries/zed/9.3-task-system>)
  * [Vim Mode](</zed-industries/zed/10-vim-mode>)
  * [Mode State Machine](</zed-industries/zed/10.1-mode-state-machine>)
  * [Operators, Motions, and Objects](</zed-industries/zed/10.2-operators-motions-and-objects>)
  * [Visual Mode](</zed-industries/zed/10.3-visual-mode>)
  * [Helix Mode Integration](</zed-industries/zed/10.4-helix-mode-integration>)
  * [AI Agent System](</zed-industries/zed/11-ai-agent-system>)
  * [Agent Communication Protocol (ACP)](</zed-industries/zed/11.1-agent-communication-protocol-\(acp\)>)
  * [Agent UI and Thread Management](</zed-industries/zed/11.2-agent-ui-and-thread-management>)
  * [Agent Connection and Implementations](</zed-industries/zed/11.3-agent-connection-and-implementations>)
  * [Tool System](</zed-industries/zed/11.4-tool-system>)
  * [Mention System and Context](</zed-industries/zed/11.5-mention-system-and-context>)
  * [Legacy Agent Thread System](</zed-industries/zed/11.6-legacy-agent-thread-system>)
  * [Remote Development and Collaboration](</zed-industries/zed/12-remote-development-and-collaboration>)
  * [Local vs Remote Architecture](</zed-industries/zed/12.1-local-vs-remote-architecture>)
  * [Remote Project Architecture](</zed-industries/zed/12.2-remote-project-architecture>)
  * [Collaboration Features](</zed-industries/zed/12.3-collaboration-features>)
  * [CRDT and Synchronization](</zed-industries/zed/12.4-crdt-and-synchronization>)


Menu

# Local vs Remote Architecture

Relevant source files

  * [crates/collab/src/tests/editor_tests.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/collab/src/tests/editor_tests.rs>)
  * [crates/collab/src/tests/integration_tests.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/collab/src/tests/integration_tests.rs>)
  * [crates/collab/src/tests/remote_editing_collaboration_tests.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/collab/src/tests/remote_editing_collaboration_tests.rs>)
  * [crates/copilot/Cargo.toml](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/copilot/Cargo.toml>)
  * [crates/copilot/src/copilot.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/copilot/src/copilot.rs>)
  * [crates/copilot/src/sign_in.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/copilot/src/sign_in.rs>)
  * [crates/editor/src/hover_links.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/editor/src/hover_links.rs>)
  * [crates/fs/src/fs.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/fs/src/fs.rs>)
  * [crates/git/src/status.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/git/src/status.rs>)
  * [crates/lsp/src/lsp.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/lsp/src/lsp.rs>)
  * [crates/prettier/src/prettier.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/prettier/src/prettier.rs>)
  * [crates/prettier/src/prettier_server.js](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/prettier/src/prettier_server.js>)
  * [crates/project/src/buffer_store.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs>)
  * [crates/project/src/lsp_command.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_command.rs>)
  * [crates/project/src/lsp_store.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs>)
  * [crates/project/src/prettier_store.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/prettier_store.rs>)
  * [crates/project/src/project.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/project.rs>)
  * [crates/project/src/project_tests.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/project_tests.rs>)
  * [crates/project/src/worktree_store.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/worktree_store.rs>)
  * [crates/proto/proto/lsp.proto](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/proto/proto/lsp.proto>)
  * [crates/remote_server/src/headless_project.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/remote_server/src/headless_project.rs>)
  * [crates/remote_server/src/remote_editing_tests.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/remote_server/src/remote_editing_tests.rs>)
  * [crates/worktree/src/worktree.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs>)
  * [crates/worktree/src/worktree_tests.rs](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree_tests.rs>)


## Purpose and Scope

This document explains the architectural pattern that enables Zed to operate in both local and remote modes. Throughout the codebase, major subsystems like language servers, file trees, and buffers are designed with a unified interface that abstracts whether they're operating on local resources or proxying requests to a remote server.

For information about the server-side project implementation and RPC handlers, see [Remote Project Architecture](</zed-industries/zed/12.2-remote-project-architecture>). For real-time collaboration features built on this architecture, see [Collaboration Features](</zed-industries/zed/12.3-collaboration-features>).

## Architectural Overview

Zed's architecture uses a consistent pattern across all major stores: each store has a unified interface with separate Local and Remote implementations. The Local variant directly accesses system resources (filesystem, language servers, git repositories), while the Remote variant acts as an RPC proxy, forwarding requests to a server that runs the Local implementation.


Sources: [crates/project/src/lsp_store.rs1-11](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L1-L11>) [crates/worktree/src/worktree.rs86-90](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L86-L90>) [crates/project/src/buffer_store.rs49-62](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L49-L62>)

## The Store Pattern

Each major store follows this enum-based pattern:


The pattern is implemented as:

**LspStore Enum Structure:**

  * `LocalLspStore` \- contains actual language server instances and manages their lifecycle
  * `RemoteLspStore` \- holds RPC client and project ID, forwards all requests


**WorktreeStore Enum Structure:**

  * `LocalWorktree` \- scans filesystem, monitors changes via file watcher
  * `RemoteWorktree` \- receives filesystem updates via RPC, no direct FS access


**BufferStore Split:**

  * `LocalBufferStore` \- manages buffer lifecycle and file synchronization
  * `RemoteBufferStore` \- proxies buffer operations and receives updates


Sources: [crates/project/src/lsp_store.rs254-299](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L254-L299>) [crates/worktree/src/worktree.rs121-159](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L121-L159>) [crates/project/src/buffer_store.rs31-68](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L31-L68>)

## Local Store Architecture

### Direct Resource Access

Local stores directly interact with system resources without any indirection:


### LocalLspStore Implementation

The `LocalLspStore` is responsible for:

  * Starting and managing language server processes
  * Opening buffers in language servers via `textDocument/didOpen`
  * Tracking which buffers are registered with which servers
  * Handling LSP notifications and requests directly


Key fields:

  * `language_servers: HashMap<LanguageServerId, LanguageServerState>` \- running servers
  * `registered_buffers: HashMap<BufferId, usize>` \- buffer registration count
  * `buffers_opened_in_servers: HashMap<BufferId, HashSet<LanguageServerId>>` \- tracking


The `start_language_server` method spawns the actual process and initializes it:

Sources: [crates/project/src/lsp_store.rs254-299](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L254-L299>) [crates/project/src/lsp_store.rs359-570](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L359-L570>)

### LocalWorktree Implementation

The `LocalWorktree`:

  * Scans directory trees recursively
  * Monitors filesystem changes via platform-specific watchers
  * Maintains git repository state
  * Applies `.gitignore` rules


Key fields:

  * `snapshot: LocalSnapshot` \- current filesystem state
  * `scan_requests_tx: channel::Sender<ScanRequest>` \- scan coordination
  * `fs: Arc<dyn Fs>` \- filesystem abstraction
  * `_background_scanner_tasks: Vec<Task<()>>` \- scanning background tasks


Sources: [crates/worktree/src/worktree.rs121-135](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L121-L135>) [crates/worktree/src/worktree.rs356-471](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L356-L471>)

### LocalBufferStore Implementation

The `LocalBufferStore`:

  * Maps file entries to buffer IDs
  * Handles buffer file associations
  * Coordinates with worktree for file operations


Key fields:

  * `local_buffer_ids_by_entry_id: HashMap<ProjectEntryId, BufferId>`
  * `worktree_store: Entity<WorktreeStore>`


Sources: [crates/project/src/buffer_store.rs64-68](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L64-L68>)

## Remote Store Architecture

### RPC Proxy Pattern

Remote stores act as lightweight proxies that forward all operations via RPC:


### RemoteLspStore Implementation

The `RemoteLspStore` has minimal state:

  * `upstream_client: AnyProtoClient` \- RPC connection
  * `project_id: u64` \- identifies the remote project
  * No language server instances or processes


Example: Requesting completions

The remote implementation forwards the request via `proto::GetCompletions` and deserializes the response. All actual LSP communication happens server-side.

Sources: [crates/project/src/lsp_store.rs3001-3150](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L3001-L3150>)

### RemoteWorktree Implementation

The `RemoteWorktree`:

  * Receives filesystem updates via `proto::UpdateWorktree` messages
  * Maintains a local copy of the snapshot for read operations
  * No file watcher or filesystem scanning


Key fields:

  * `snapshot: Snapshot` \- local cached snapshot
  * `background_snapshot: Arc<Mutex<(Snapshot, Vec<proto::UpdateWorktree>)>>`
  * `client: AnyProtoClient`
  * `project_id: u64`


Update handling:


Sources: [crates/worktree/src/worktree.rs147-159](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L147-L159>) [crates/worktree/src/worktree.rs473-575](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L473-L575>)

### RemoteBufferStore Implementation

The `RemoteBufferStore`:

  * Waits for buffers to be streamed from the server
  * Applies operations received via RPC
  * Handles save requests by forwarding to server


Key fields:

  * `upstream_client: AnyProtoClient`
  * `project_id: u64`
  * `loading_remote_buffers_by_id: HashMap<BufferId, Entity<Buffer>>`
  * `remote_buffer_listeners: HashMap<BufferId, Vec<oneshot::Sender<Result<Entity<Buffer>>>>>`


Buffer creation flow:

  1. Client requests buffer via `proto::OpenBufferByPath`
  2. Server sends `proto::CreateBufferForPeer` with state
  3. Server sends additional `Chunk` messages if buffer is large
  4. Client assembles buffer and notifies waiters


Sources: [crates/project/src/buffer_store.rs54-62](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L54-L62>) [crates/project/src/buffer_store.rs156-245](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L156-L245>)

## Server-Side Architecture

### HeadlessProject Structure

The `HeadlessProject` runs on the remote server (e.g., via SSH) and hosts all the Local store implementations:


The `HeadlessProject` fields:

  * `worktree_store: Entity<WorktreeStore>` \- with Local variant
  * `buffer_store: Entity<BufferStore>` \- with Local variant
  * `lsp_store: Entity<LspStore>` \- with Local variant
  * `session: AnyProtoClient` \- RPC connection to client
  * `fs: Arc<dyn Fs>` \- server filesystem access


When initialized, each store is configured to be "shared" via the session, which registers RPC handlers.

Sources: [crates/remote_server/src/headless_project.rs45-63](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/remote_server/src/headless_project.rs#L45-L63>) [crates/remote_server/src/headless_project.rs74-176](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/remote_server/src/headless_project.rs#L74-L176>)

### Store Sharing Mechanism

Each store has a `.shared()` method that registers RPC handlers:

**WorktreeStore sharing:**

  * Registers `UpdateWorktree` to stream filesystem changes
  * Registers `CreateProjectEntry`, `RenameProjectEntry`, etc.


**BufferStore sharing:**

  * Registers `CreateBufferForPeer` to stream buffer contents
  * Registers `SaveBuffer` handler
  * Registers `UpdateBuffer` to receive edits from client


**LspStore sharing:**

  * Registers handlers for all LSP operations: `GetDefinition`, `GetCompletions`, `PerformRename`, etc.
  * Streams diagnostics via `UpdateDiagnosticSummary`


Sources: [crates/project/src/worktree_store.rs168-297](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/worktree_store.rs#L168-L297>) [crates/project/src/buffer_store.rs573-756](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L573-L756>) [crates/project/src/lsp_store.rs3214-3458](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L3214-L3458>)

## RPC Communication Protocol

### Message Flow for LSP Operations

Example: Get Completions


Key proto messages:

  * `proto::GetCompletions` \- request with buffer_id and position
  * `proto::GetCompletionsResponse` \- completions with labels and edits
  * `proto::GetDefinition` / `GetDefinitionResponse`
  * `proto::PerformRename` / `PerformRenameResponse`


Sources: [crates/proto/proto/lsp.proto1-258](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/proto/proto/lsp.proto#L1-L258>) [crates/project/src/lsp_command.rs1-41](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_command.rs#L1-L41>)

### Buffer Synchronization

Buffers are synchronized using CRDT operations:


Buffer operations include:

  * `proto::UpdateBuffer` \- CRDT operations (insert/delete)
  * `proto::SaveBuffer` \- persist to disk
  * `proto::CreateBufferForPeer` \- initial state transfer


Sources: [crates/project/src/buffer_store.rs156-245](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L156-L245>) [crates/language/src/proto.rs1-50](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/language/src/proto.rs#L1-L50>)

### Filesystem Update Streaming

Worktree changes are streamed continuously:


The `proto::UpdateWorktree` message contains:

  * `updated_entries: Vec<Entry>` \- new/modified entries
  * `removed_entries: Vec<u64>` \- deleted entry IDs
  * `updated_repositories: Vec<RepositoryEntry>` \- git repo changes
  * `scan_id: u64` \- monotonic scan counter


Sources: [crates/worktree/src/worktree.rs680-701](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L680-L701>) [crates/proto/proto/worktree.proto1-100](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/proto/proto/worktree.proto#L1-L100>)

## Store-Specific Implementations

### LspStore: Language Server Management

#### Local Architecture

The `LocalLspStore` manages the complete language server lifecycle:

**Server startup sequence:**

  1. `get_or_insert_language_server()` checks for existing server
  2. `start_language_server()` spawns process via `LanguageServer::new()`
  3. Server process initialization with `initialize` request
  4. Send `didChangeConfiguration` with workspace settings
  5. Register in `language_servers` map and `language_server_ids` map


**Buffer registration:**

  1. `register_buffer_with_language_servers()` determines appropriate servers
  2. Send `textDocument/didOpen` for each server
  3. Track in `registered_buffers` and `buffers_opened_in_servers`
  4. Buffer changes trigger `textDocument/didChange` notifications


**Request handling:**

  * Each LSP request (completions, definitions, etc.) uses the `LspCommand` trait
  * Commands serialize to LSP params, execute via server, deserialize response
  * Responses are transformed to Zed's internal types


Sources: [crates/project/src/lsp_store.rs315-570](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L315-L570>) [crates/project/src/lsp_store.rs1500-1700](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L1500-L1700>)

#### Remote Architecture

The `RemoteLspStore` is minimal:

**Structure:**
    
    
    RemoteLspStore {
        upstream_client: AnyProtoClient,
        project_id: u64,
    }
    

**Operation forwarding:**

  * All methods immediately serialize to proto and forward via RPC
  * No knowledge of actual language servers
  * Waits for responses and deserializes back to Zed types


Example request flow: `get_completions()` → serialize to `proto::GetCompletions` → send via RPC → receive `proto::GetCompletionsResponse` → deserialize to `Vec<Completion>`

Sources: [crates/project/src/lsp_store.rs3001-3150](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L3001-L3150>)

### WorktreeStore: Filesystem Management

#### Local Architecture

The `LocalWorktree` performs active filesystem scanning:

**Background scanning:**

  1. Spawn background tasks in `start_background_scanner()`
  2. Monitor filesystem events via platform-specific watcher
  3. Process scan requests via `scan_requests_rx` channel
  4. Update `LocalSnapshot` with new entries
  5. Emit `UpdatedEntries` events


**Snapshot structure:**

  * `entries_by_path: SumTree<Entry>` \- B-tree indexed by path
  * `entries_by_id: SumTree<PathEntry>` \- B-tree indexed by ID
  * `git_repositories: TreeMap<ProjectEntryId, LocalRepositoryEntry>`
  * `ignores_by_parent_abs_path: HashMap<Arc<Path>, (Arc<Gitignore>, bool)>`


**Git integration:**

  * Detect `.git` directories during scan
  * Load `.gitignore` files and build ignore stacks
  * Track repository state for each worktree path


Sources: [crates/worktree/src/worktree.rs121-135](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L121-L135>) [crates/worktree/src/worktree.rs233-246](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L233-L246>)

#### Remote Architecture

The `RemoteWorktree` maintains a synchronized snapshot:

**Update processing:**

  1. Receive `proto::UpdateWorktree` messages in background task
  2. Apply to `background_snapshot`
  3. Queue updates in vector
  4. Foreground task reads updates and applies to UI snapshot
  5. Emit events for UI updates


**No scanning capability:**

  * Cannot initiate filesystem operations
  * Cannot watch files
  * Read-only snapshot maintained by server updates


**Snapshot subscription:**

  * Clients can wait for specific scan_id via `snapshot_subscriptions`
  * Used to ensure file operations complete before proceeding


Sources: [crates/worktree/src/worktree.rs473-575](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L473-L575>)

### BufferStore: Buffer Lifecycle

#### Local Architecture

The `LocalBufferStore` coordinates buffer-file associations:

**Opening buffers:**

  1. Check `path_to_buffer_id` map for existing buffer
  2. If not present, load from filesystem via `Worktree::load_file()`
  3. Create `Buffer` entity with file contents
  4. Register in `opened_buffers` and `path_to_buffer_id`
  5. Subscribe to buffer events for file association changes


**Entry tracking:**

  * `local_buffer_ids_by_entry_id` maps worktree entry to buffer
  * Updated when buffer file associations change
  * Handles file moves/renames by updating mappings


Sources: [crates/project/src/buffer_store.rs64-68](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L64-L68>) [crates/project/src/buffer_store.rs500-700](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L500-L700>)

#### Remote Architecture

The `RemoteBufferStore` coordinates buffer streaming:

**Opening buffers:**

  1. Send `proto::OpenBufferByPath` request
  2. Server responds with buffer_id
  3. Wait for `proto::CreateBufferForPeer` messages
  4. First message contains base state
  5. Subsequent chunk messages contain operations
  6. Assemble complete buffer from state + operations


**Buffer streaming:**

  * Large buffers sent in chunks to avoid RPC message size limits
  * `loading_remote_buffers_by_id` tracks in-progress loads
  * `remote_buffer_listeners` notified when buffer complete


**Saving buffers:**

  * `save_remote_buffer()` sends `proto::SaveBuffer` with version
  * Server persists and responds with new mtime
  * Client updates buffer disk state


Sources: [crates/project/src/buffer_store.rs103-154](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L103-L154>) [crates/project/src/buffer_store.rs291-340](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/buffer_store.rs#L291-L340>)

## Design Rationale

### Why This Architecture?

**Unified Interface:**

  * Client code (Editor, Workspace) doesn't need to know if it's local or remote
  * Same APIs work in both modes
  * Easy to switch between modes (e.g., sharing a local project)


**Minimal Remote State:**

  * Remote stores are lightweight proxies
  * All complex logic lives in Local implementations
  * Reduces duplication and bugs


**Server-Side Resources:**

  * Language servers run on remote machine with access to source code
  * No network latency for LSP operations on server
  * Git operations use server's git installation


**Efficient Synchronization:**

  * CRDT-based buffer sync allows concurrent editing
  * Incremental worktree updates minimize bandwidth
  * Snapshots enable efficient queries without RPC


Sources: [crates/project/src/lsp_store.rs1-11](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L1-L11>) [crates/remote_server/src/headless_project.rs1-20](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/remote_server/src/headless_project.rs#L1-L20>)

### Comparison: Local vs Remote Behavior

Aspect| Local| Remote  
---|---|---  
Language Servers| Spawned as child processes| Run on server, RPC proxy  
Filesystem Access| Direct via `fs: Arc<dyn Fs>`| Via `proto::UpdateWorktree` stream  
Buffer Loading| Read from local files| Streamed via `proto::CreateBufferForPeer`  
LSP Requests| Direct to language server| Via `proto::Get*` messages  
File Watching| Platform-specific watcher| Updates pushed from server  
Git Operations| Direct libgit2 calls| Proxied via RPC  
Latency| ~0ms| Network latency + processing  
Resource Location| Client machine| Server machine  
  
### Performance Considerations

**Network Efficiency:**

  * Batched updates reduce RPC overhead
  * Snapshot caching enables local queries
  * CRDT operations minimize sync messages


**Latency Handling:**

  * Optimistic updates where possible
  * Background synchronization
  * UI remains responsive during RPC calls


**Resource Usage:**

  * Remote stores use minimal memory
  * Language servers run only on server
  * File watching only on machine with filesystem


Sources: [crates/project/src/lsp_store.rs1-50](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/project/src/lsp_store.rs#L1-L50>) [crates/worktree/src/worktree.rs1-100](<https://github.com/zed-industries/zed/blob/4109c9dd/crates/worktree/src/worktree.rs#L1-L100>)

Dismiss

Refresh this wiki

This wiki was recently refreshed. Please wait 7 days to refresh again.

### On this page

  * [Local vs Remote Architecture](<#local-vs-remote-architecture>)
  * [Purpose and Scope](<#purpose-and-scope>)
  * [Architectural Overview](<#architectural-overview>)
  * [The Store Pattern](<#the-store-pattern>)
  * [Local Store Architecture](<#local-store-architecture>)
  * [Direct Resource Access](<#direct-resource-access>)
  * [LocalLspStore Implementation](<#locallspstore-implementation>)
  * [LocalWorktree Implementation](<#localworktree-implementation>)
  * [LocalBufferStore Implementation](<#localbufferstore-implementation>)
  * [Remote Store Architecture](<#remote-store-architecture>)
  * [RPC Proxy Pattern](<#rpc-proxy-pattern>)
  * [RemoteLspStore Implementation](<#remotelspstore-implementation>)
  * [RemoteWorktree Implementation](<#remoteworktree-implementation>)
  * [RemoteBufferStore Implementation](<#remotebufferstore-implementation>)
  * [Server-Side Architecture](<#server-side-architecture>)
  * [HeadlessProject Structure](<#headlessproject-structure>)
  * [Store Sharing Mechanism](<#store-sharing-mechanism>)
  * [RPC Communication Protocol](<#rpc-communication-protocol>)
  * [Message Flow for LSP Operations](<#message-flow-for-lsp-operations>)
  * [Buffer Synchronization](<#buffer-synchronization>)
  * [Filesystem Update Streaming](<#filesystem-update-streaming>)
  * [Store-Specific Implementations](<#store-specific-implementations>)
  * [LspStore: Language Server Management](<#lspstore-language-server-management>)
  * [Local Architecture](<#local-architecture>)
  * [Remote Architecture](<#remote-architecture>)
  * [WorktreeStore: Filesystem Management](<#worktreestore-filesystem-management>)
  * [Local Architecture](<#local-architecture-1>)
  * [Remote Architecture](<#remote-architecture-1>)
  * [BufferStore: Buffer Lifecycle](<#bufferstore-buffer-lifecycle>)
  * [Local Architecture](<#local-architecture-2>)
  * [Remote Architecture](<#remote-architecture-2>)
  * [Design Rationale](<#design-rationale>)
  * [Why This Architecture?](<#why-this-architecture>)
  * [Comparison: Local vs Remote Behavior](<#comparison-local-vs-remote-behavior>)
  * [Performance Considerations](<#performance-considerations>)
